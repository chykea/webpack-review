<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /*
            1. 初始化参数:有两种方式,第一种是没有配置文件(webpack.config.js),第二种是有配置文件
                有配置文件的情况: 从配置文件中和shell语句读取并合并参数,得到最终参数
            2. 开始编译: 用得到的最终参数来获取Compiler对象,加载所有配置的插件,并执行Compiler对象的run方法开始执行编译
            3. 确定入口: 根据配置中的entry确定入口文件
            4. 编译模块: 从入口文件出发,调用所有配置的loader对模块进行编译,再找出模块依赖的模块,继续调用loader进行编译,直到所有入口依赖文件都经过编译
            5. 完成模块编译: 经过第4步使用Loader编译所有模块之后,得到每个模块之间的依赖关系
            6. 输出资源: 根据入口与模块之间的依赖关系,组装成一个个包含多模块的chunk,再把每个chunk转换成单独的文件加入到输出列表,这一步是确定输出内容的最后机会
                chunk: 是在webpack打包过程中,产生的一堆module的集合
                在webpack.config.js中,有一个字段是entry(用于指定入口文件的路径)以前学习的时候是一个字符串,
                但entry其实也可以是一个对象,可以添加对应字段,来指定,如果有多个字段,会生成多个chunk,
                此时output中就不能只指定一个文件名了,可以通过[name]进行对应chunk的匹配
                entry:{
                    main: './src/main.js', // main文件
                    other:'./src/other.js' //   
                },
                output:{
                    path:'', // 输出文件地址
                    filename: '[name].js'
                }
            7. 输出完成: 确定输出内容之后,根据配置确定输出的路径和文件名,输出

        */
    </script>
</body>

</html>